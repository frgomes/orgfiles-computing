* Notes on Design Principles, Programming Languages, Tooling and Frameworks
** Design Principles
*** Object Oriented Programming
 In this section, we describe key concepts involving Object Oriented Programming (OOP) and why modern systems are slowly finding their way out of OOP.
**** OOP is not about objects of the real world
 An assumption involving OOP is that our program, having so-called /objects/, can mimick objects of the real world. For example, we know from geometry that a /square/ is just a particular case of a /rectangle/ which happens to have both =height= and =weight= measuring just the same. Since we've learned this concept from geometry, it's more or less straightforward to believe that =class Square= is just a particular case of =class Rectangle= or, in other words, =class Square extends Rectangle=.

 As we will see later when we visit the Liskov Substitution Principle in far more detail, =class Square= is not really a particular case of =class Rectangle= because an instance of =Square= could not be substituted by an instance of a =Rectangle= without breaking the application. In other words, when you say that =class B extends A= you mean to say that B adds extra functionality of A, keeping the original functionality of A instact, which translates to say that overloaded methods should honour the behavior of the base class, something which does not really happen in the case of =class Square= and =class Rectangle=. As already stated, this subject will be better covered later.


 It's widely assumed that /object oriented programming/ is about mimicking /objects/ of the real world, but actually, this is amisconception since we've just showed above in the case of squares and rectangles, even though without going deep in details. This sort misconception arises because the coined terminology /object oriented/ leads to multiple [[http://rationalwiki.org/wiki/Equivocation][fallacies of equivocation]] in our programs every time we state that behaviour of /objects in our applications/ mimick behaviour of /objects in the real world/, in particular when we state that relationships between objects in our applications mimick relationships between objects in the real world.

 Instead of /object oriented/, it's argued that /message oriented/ would be more appropriate, despite arguably: a more difficult terminology to be explained and understood. Everyone understands what an /object/ is in the real world and so, everyone understand what an /object/ is in programming... and everyone understands wrong! Maybe another term like /message oriented/ if coined instead of /object oriented/ would be more appropriate but unfortunately, the past cannot be rewritten and /object oriented/ is here to stay.

 Anyway, a /message oriented programming/ could be understood as a /communication between endpoints/ which transfers data between these endpoints, leading to a change of internal state between these endpoints. A good example would be an instance of an object =A= which calls a method of object =B=, making =B= change its internal state. The very fact that you /call a method/ can be understood as a /message passing/ between =A= and =B=, making =B= change its internal state.

**** OOP promotes shared mutable state

 One of the pillars of OOP is a concept called /encapsulation/ which states that an /object/ is the sole responsible for managing its own data. In other words, and object carries /data implicitly/ which supports the implementation of a certain /behaviour explicitly/. In other words, when we call a method from an /object/ we are, in general, changing its internal state. Back to the concept of /message oriented programming/, when A calls B a logic entanglement is created between A and B, which means to say that the /state of A/ is dependent of the /state of B/. This creates a problem in multithreaded applications as we will see.

 Imagine one =Thread T1= where =object A= calls =object B= and suppose that there's another =Thread T2= which contains a reference to the same =object B=. There's chance that something inside =Thread T2= calls =object B=, provoking a change in its internal state, leading to a side effect in =object A=, since the internal state of =object A= depends on =object B=.

 Another problem which arises from objects keeping internal state is related to web services. Imagine a web server which creates several objects in memory when a request arrives, each object keeping a certain amount of information as its internal state. If millions of requests arrive in a matter of few seconds, very quickly the entire memory will be filled with objects still alive and still holding some internal state. In this case, we might get rid of the problem entirely simply adopting the design principle of not maintaining any internal state whatsoever.

*** TODO [0/3] Functional Programming
 - [ ] Functional Programming is not anything new
 - [ ] Functions as first class citizens
 - [ ] Immutability
*** TODO [0/5] SOLID principles for system design
**** Single responsibility
  It states that and object should have only one responsibility. Doing so, when its implementation changes, it delivers more functionality on the dimension covered by its responsibility, not causing any harm to other functionalities.
**** Open for extension / Close for change
 In addition to single responsibility, an object should allow exchange in its functionality, but should prevent changes in current implemented functionalities. The /extension/, in one hand, can be understood as exposure of additional methods in the object itself. In other hand, can be understood as allowing extended classes easily borrow implementation from a given class, extending functionalities this way.

 Being /close to change/ can be understood as hiding internal implementation details which could change the object internal state. It can also be understood as design pattern which guides to relatively high granularity of the code so that functionalities are implemented as a composition of finer grained functionalities. This way, by composing fine grained functionalities in new creative ways we can accomplish innovative functionalities without really touching the small building block which composes such functionalities.
    
**** TODO [0/0] Liskov Substitution Principle
 It basically states that subtypes could be substitued by their base types without breaking the application.

**** TODO [0/0] Interface Segregation
**** TODO [0/0] Dependency Inversion
*** ACID principles for database systems
ACID stands for Atomiciity, Consistency, Integrity and Durability.

- *Atomicity* requires that each transaction be "all or nothing": if one part of the transaction fails, then the entire transaction fails, and the database state is left unchanged.

- *Consistency* ensures that any transaction will bring the database from one valid state to another.

- *Isolation* ensures that the concurrent execution of transactions results in a system state that would be obtained if transactions were executed sequentially, i.e., one after the other. Providing isolation is the main goal of concurrency control.

- *Durability* ensures that once a transaction has been committed, it will remain so, even in the event of power loss, crashes, or errors.

*** The CAP Theorem for distributed systems
CAP stands for Consistency, Availability and network Partitions.

The CAP Theorem states that all 3 principles cannot be achieved at the same time and so, applications must choose at most 2 of these principles.

In distributed systems, in the face of network partitions, we have to choose between consistency and availability. Usually, high availability is a requirement, which means that we are left with the problem of having to manage an inconsistent global state.

The common approach for the problem of an inconsistent global state is simply believing that we can go ahead and perform the operation we have to do. In case everything goes according to plan, we are fine; otherwise, we have to apologize and perform a compensative action later.

#+BEGIN_QUOTE
"It's easier to ask for forgiveness than it is to get permission."
-- Grace Hopper
#+END_QUOTE

The idea of asking for forgiveness and performing a compensative action later is sometimes known as Apology-Oriented Programming.

*** TODO Event Driven Architecture
*** TODO [0/1] ACID 2.0 principles for distributed systems
ACID in the context of distributed systems is a summary of a set of principles for scalable and resilient protocol and APIdesign. ACID, in this context, means: Associative, Commutative, Idempotent and Distributed.

- *Associative* that messages can be grouped in batches.

- [ ] *Commutative* means that order of messages do not matter.

- *Idempotent* means that duplication of messages does not matter.

- *Distributed* means distributed, just for making the acronym look beautiful.

*** TODO CQRS principle for microservices

*** TODO Event source

*** TODO Kafka?

** [0/0] Java
 We try to group subjects by their relative importance when a given version of the Java language was currently mainstream.
*** [0/2] Java 5 language features
 - [ ] Generics
*** [0/6] Java 6 performance and stability
 - [ ] Primitive types, boxing and unboxing
 - [ ] String pool
 - [ ] Hashing algorithm
 - [ ] Low level concurrency
 - [ ] High level concurrency
*** Java7
**** Exception Handling Changes
 - Use /try with resources/ statement with any object that implements =AutoCloseable=.
 - The try-with-resources statement rethrows the primary exception if closing a resource throws another exception.
#+BEGIN_SRC java
static String readFirstLineFromFile(String path) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader(path))) {
        return br.readLine();
    }
}

#+END_SRC
**** Working with Files
 - Use the =Path= interface instead of the =File= class.
 - The =Files= class has static methods for copying, moving, and deleting files, and for creating files and directories.
 - You can read and write all characters, or all lines, of a text file with a single command.
#+BEGIN_SRC 
// read all lines
List<String> lines = Files.readAllLines(Paths.get("file"), StandardCharsets.UTF_8);

// read the entire file as a single String
String text = new String(Files.readAllBytes(Paths.get("file")), StandardCharsets.UTF_8);
#+END_SRC
**** Implementing the equals, hashCode, and compareTo Methods
 - Use =Objects.equals= for null-safe equality testing.
 - =Objects.hash= makes it simple to implement the hashCode method.
 - When comparing numbers in a comparator, use the static compare method.
#+BEGIN_SRC 
  int x = ...;
  int y = ...;
  boolean b = (Integer.compare(x, y) == 0);
#+END_SRC
**** Security Requirements
 - Applets and Java Web Start applications continue to be supported in corporate environments, but they may no longer be viable for home users.
*** [0/0] Java8
**** [0/11] Lambda expressions
***** [ ] Functional interfaces
***** [ ] Method references
***** [ ] Constructor references
***** [ ] Variable scope
***** [ ] Default methods
***** [ ] Static methods in interfaces
***** [ ] Deferred Execution
***** [ ] Compositions
***** [ ] Laziness
***** [ ] Parallel operations
***** [ ] Dealing exceptions
***** [ ] Monadic Operations
**** Collections
Methods added to Collection Classes
| class/interface | new methods                                                                                                      |
|-----------------+------------------------------------------------------------------------------------------------------------------|
| Iterable        | forEach                                                                                                          |
| Collection      | removeIf                                                                                                         |
| List            | replaceAll, sort                                                                                                 |
| Map             | forEach, replace, replaceAll, remove(key, value), putIfAbsent, compute, computeIfAbsent, computeIfPresent, merge |
| Iterator        | forEachRemaining                                                                                                 |
| BitSet          | stream                                                                                                           |

**** [0/14] Stream API
***** [ ] From Iteration to Stream Operations
***** [ ] Stream Creation
***** [ ] The filter, map, and flatMap Methods
***** [ ] Extracting Substreams and Combining Streams
***** [ ] Stateful Transformations
***** [ ] Simple Reductions
***** [ ] The Optional Type
***** [ ] Reduction Operations
***** [ ] Collecting Results
***** [ ] Collecting into Maps
***** [ ] Grouping and Partitioning
***** [ ] Primitive Type Streams
***** [ ] Parallel Streams
***** [ ] Functional Interfaces 
**** [0/4] Concurrency Enhancements 
***** Atomic values
Instead of writing
#+BEGIN_SRC 
do {   
  oldValue = largest.get();
  newValue = Math.max(oldValue, observed);
} while (!largest.compareAndSet(oldValue, newValue));
#+END_SRC
you can now write
#+BEGIN_SRC 
largest.updateAndGet(x -> Math.max(x, observed));
#+END_SRC

Methods =updateAndGet=, =getAndUpda=, =getAndAccumulate= are provided for the classes AtomicInteger, AtomicIntegerArray, AtomicIntegerFieldUpdater, AtomicLongArray, AtomicLongFieldUpdater, AtomicReference, AtomicReferenceArray, and AtomicReferenceFieldUpdater.

A =LongAdder= are composed internally of multiple variables whose collective sum is the current value. Multiple threads can update different summands, and new summands are automatically provided when the number of threads increases. This is efficient in the common situation where the value of the sum is not needed until after all work has been done. The performance improvement can be substantial.

A =LongAccumulator= is similar to =LongAdder= internally, but its constructor employs the idea of neutral element of the operation (or identity value).

=DoubleAdder= and =DoubleAccumulator= work in similar ways, but for =double= values.


***** [ ] ConcurrentHashMap enhancements
***** [ ] Parallel Array enhancements
***** [ ] Completable Futures
**** [0/7] New Date and Time API
***** [ ] The Time Line
***** [ ] Local Dates
***** [ ] Date Adjusters
***** [ ] Local Time
***** [ ] Zoned Time
***** [ ] Formatting and Parsing
***** [ ] Interoperating with Legacy Code 
**** [0/11] Miscellaneous Goodies
***** Strings
Joining strings finally becomes easier.
#+BEGIN_SRC 
String.join(", ", a, b, c);
#+END_SRC
***** Number classes
- Integer and types now support unsigned arithmetic.
- Detection of overflow and underflow involving types =int= and =long= via new methods =Math.(add|subtract|multiply, increment|decrement|negate)Exact=
 =int= and =long=.
***** [ ] Collections
***** [ ] Working with files
***** [ ] Annotations
***** [ ] SAM
***** [ ] Support for unsigned numeric types
***** [ ] Other changes

** [0/0] Scala
*** [0/4] Principles
***** [ ] Multi paradigm
***** [ ] First class functions
***** [ ] Immutability
***** [ ] No explicit static allocation
***** [ ] SBT build system
**** [0/3] Language Overview (L1)
     DEADLINE: <2017-01-16 Mon>

***** [ ] Classes and Objects
***** [ ] Methods and Functions
***** [ ] Traits and mixins

**** [0/4] Language Overview (L2)
     DEADLINE: <2017-01-16 Mon>

***** [ ] Pattern matching
***** [ ] Early initialization
***** [ ] Early return
***** [ ] Types, types and more types

**** [0/2] Language Overview (L3)
     DEADLINE: <2017-01-16 Mon>

***** Tail recursion @tailrec
***** Delimited continuations @cps

 
